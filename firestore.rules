rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() { return request.auth != null; }
    function isAdmin() { return isSignedIn() && request.auth.token.admin == true; }
    function isOwner(uid) { return isSignedIn() && request.auth.uid == uid; }

    // Public parks catalog: only admin can write
    match /parks/{parkId} {
      allow read: if true;
      allow create, update, delete: if isAdmin();
    }

    // User profiles (publicly readable, owner-maintained)
    match /users/{uid} {
      allow read: if true;

      // Require displayName on create (2â€“30 chars)
      allow create: if isOwner(uid)
        && request.resource.data.displayName is string
        && request.resource.data.displayName.matches('^.{2,30}$');

      // Only allow owner to edit limited fields; keep displayName non-empty
      allow update: if isOwner(uid)
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(['displayName','photoURL','bio'])
        && request.resource.data.displayName is string
        && request.resource.data.displayName.matches('^.{2,30}$');
    }

    // Each user's "visited parks" subcollection (private to owner)
    match /users/{uid}/visited/{parkId} {
      allow read, write: if isOwner(uid);
    }

    // Public photo metadata for parks
    // (Storage object is covered in storage.rules; this is the Firestore doc)
    match /parkPhotos/{parkId}/{photoId} {
      allow read: if true;
      // Anyone signed in can create; must credit themselves with displayName
      allow create: if isSignedIn()
        && request.resource.data.uid == request.auth.uid
        && request.resource.data.displayName is string
        && request.resource.data.displayName.matches('^.{2,30}$');
      // Only the owner can update/delete their photo doc
      allow update, delete: if isSignedIn()
        && resource.data.uid == request.auth.uid;
    }
  }
}
